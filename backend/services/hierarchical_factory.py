"""
üèóÔ∏è Hierarchical Factory Architecture - Arquitectura Factory Jer√°rquica
- IScraper: Interfaz com√∫n con execute()
- CountryFactory: Factory por pa√≠s que delega a provincias
- ProvincialFactory: Factory provincial espec√≠fico
"""

import asyncio
import logging
from typing import List, Dict, Any, Optional
from abc import ABC, abstractmethod
from datetime import datetime

logger = logging.getLogger(__name__)

# üîå INTERFACE COM√öN
class IScraper(ABC):
    """
    üîå Interfaz com√∫n - TODOS implementan execute()
    """
    
    @abstractmethod
    async def execute(self) -> List[Dict[str, Any]]:
        """Ejecutar scraper y retornar eventos"""
        pass
    
    @property
    @abstractmethod
    def name(self) -> str:
        """Nombre del scraper para logging"""
        pass

# üè≠ FACTORY ABSTRACTO BASE
class BaseFactory(IScraper):
    """
    üè≠ Factory base - maneja timing y logging autom√°ticamente
    """
    
    def __init__(self, location: str):
        self.location = location
        self.start_time = None
        self.events = []
        
    async def execute(self) -> List[Dict[str, Any]]:
        """Template method - mide tiempo y logs autom√°ticamente"""
        self.start_time = datetime.now()
        logger.info(f"üöÄ INICIANDO: {self.name} para {self.location}")
        
        try:
            # Delegar a implementaci√≥n espec√≠fica
            self.events = await self._execute_internal()
            
            elapsed = (datetime.now() - self.start_time).total_seconds()
            logger.info(f"‚úÖ COMPLETADO: {self.name} - {len(self.events)} eventos en {elapsed:.2f}s")
            
            return self.events
            
        except Exception as e:
            elapsed = (datetime.now() - self.start_time).total_seconds() if self.start_time else 0
            logger.error(f"‚ùå ERROR: {self.name} - {str(e)} ({elapsed:.2f}s)")
            return []
    
    @abstractmethod
    async def _execute_internal(self) -> List[Dict[str, Any]]:
        """Implementaci√≥n espec√≠fica del factory"""
        pass

# üá¶üá∑ ARGENTINA COUNTRY FACTORY
class ArgentinaFactory(BaseFactory):
    """
    üá¶üá∑ Factory Argentina - maneja todo el pa√≠s
    Si se especifica provincia, delega a ProvincialFactory
    Si no, ejecuta scrapers nacionales
    """
    
    def __init__(self, location: str, province: Optional[str] = None):
        super().__init__(location)
        self.province = province
        
    @property
    def name(self) -> str:
        if self.province:
            return f"Argentina_{self.province}_Factory"
        return "Argentina_National_Factory"
        
    async def _execute_internal(self) -> List[Dict[str, Any]]:
        """
        L√≥gica de Argentina:
        - Si tiene provincia espec√≠fica -> usar ProvincialFactory
        - Si no -> usar scrapers nacionales
        """
        if self.province:
            logger.info(f"üèõÔ∏è Provincia espec√≠fica detectada: {self.province}")
            provincial_factory = ArgentinaProvincialFactory(self.location, self.province)
            return await provincial_factory.execute()
        else:
            logger.info(f"üá¶üá∑ Ejecutando scrapers nacionales de Argentina")
            return await self._execute_national_scrapers()
    
    async def _execute_national_scrapers(self) -> List[Dict[str, Any]]:
        """Ejecutar scrapers a nivel nacional argentino"""
        try:
            # Import din√°mico para evitar circular imports
            from api.multi_source import fetch_all_progressive
            
            # Usar multi_source para nivel nacional
            result = await fetch_all_progressive(location="Buenos Aires", fast=True)
            
            if result and "events" in result:
                return result["events"]
            return []
            
        except Exception as e:
            logger.error(f"‚ùå Error en scrapers nacionales Argentina: {e}")
            return []

# üèõÔ∏è ARGENTINA PROVINCIAL FACTORY  
class ArgentinaProvincialFactory(BaseFactory):
    """
    üèõÔ∏è Factory Provincial Argentina - scrapers espec√≠ficos por provincia
    """
    
    def __init__(self, location: str, province: str):
        super().__init__(location)
        self.province = province
        
    @property
    def name(self) -> str:
        return f"Argentina_{self.province}_Provincial"
        
    async def _execute_internal(self) -> List[Dict[str, Any]]:
        """
        Ejecutar scrapers provinciales espec√≠ficos
        """
        logger.info(f"üèõÔ∏è Ejecutando scrapers provinciales para {self.province}")
        
        # Mapear provincia a scrapers espec√≠ficos
        if self.province.lower() in ["c√≥rdoba", "cordoba"]:
            return await self._execute_cordoba_scrapers()
        elif self.province.lower() in ["mendoza"]:
            return await self._execute_mendoza_scrapers() 
        elif self.province.lower() in ["buenos aires", "buenosaires", "caba"]:
            return await self._execute_buenos_aires_scrapers()
        elif self.province.lower() == "generic":
            logger.info(f"üîç Provincia gen√©rica, intentando detectar desde ubicaci√≥n: {self.location}")
            return await self._execute_generic_argentina_scrapers()
        else:
            logger.warning(f"‚ö†Ô∏è No hay scrapers espec√≠ficos para {self.province}, usando gen√©rico")
            return await self._execute_generic_argentina_scrapers()
    
    async def _execute_cordoba_scrapers(self) -> List[Dict[str, Any]]:
        """Scrapers espec√≠ficos de C√≥rdoba - usa multi_source que sabemos que funciona"""
        try:
            # Import local para evitar problemas
            import sys
            import os
            backend_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            if backend_path not in sys.path:
                sys.path.insert(0, backend_path)
            
            # Usar multi_source directamente que sabemos que trae 15 eventos para C√≥rdoba
            from api.multi_source import fetch_all_progressive
            
            result = await fetch_all_progressive(location="C√≥rdoba", fast=True)
            
            if result and "events" in result:
                events = result["events"]
                logger.info(f"‚úÖ C√≥rdoba scrapers: {len(events)} eventos")
                return events
            else:
                logger.info("‚ö†Ô∏è C√≥rdoba scrapers: 0 eventos")
                return []
            
        except Exception as e:
            logger.error(f"‚ùå Error en scrapers C√≥rdoba: {e}")
            return []
    
    async def _execute_mendoza_scrapers(self) -> List[Dict[str, Any]]:
        """Scrapers espec√≠ficos de Mendoza"""
        # TODO: Implementar scrapers Mendoza espec√≠ficos
        logger.info("üç∑ Mendoza scrapers - TODO")
        return []
    
    async def _execute_buenos_aires_scrapers(self) -> List[Dict[str, Any]]:
        """Scrapers espec√≠ficos de Buenos Aires"""
        try:
            # Usar venues oficiales + multi_source
            from services.oficial_venues_scraper import OficialVenuesScraper
            from api.multi_source import fetch_all_progressive
            
            # Ejecutar en paralelo
            tasks = [
                self._get_oficial_venues_events(),
                fetch_all_progressive(location="Buenos Aires", fast=True)
            ]
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            all_events = []
            for result in results:
                if isinstance(result, dict) and "events" in result:
                    all_events.extend(result["events"])
                elif isinstance(result, list):
                    all_events.extend(result)
            
            logger.info(f"‚úÖ Buenos Aires scrapers: {len(all_events)} eventos")
            return all_events
            
        except Exception as e:
            logger.error(f"‚ùå Error en scrapers Buenos Aires: {e}")
            return []
    
    async def _get_oficial_venues_events(self) -> List[Dict[str, Any]]:
        """Helper para venues oficiales"""
        try:
            from services.oficial_venues_scraper import OficialVenuesScraper
            scraper = OficialVenuesScraper()
            return await scraper.scrape_all_venues()
        except Exception as e:
            logger.error(f"‚ùå Error venues oficiales: {e}")
            return []
    
    async def _execute_generic_argentina_scrapers(self) -> List[Dict[str, Any]]:
        """Scrapers gen√©ricos para provincias sin implementaci√≥n espec√≠fica"""
        try:
            from api.multi_source import fetch_all_progressive
            
            result = await fetch_all_progressive(location=self.location, fast=True)
            
            if result and "events" in result:
                return result["events"]
            return []
            
        except Exception as e:
            logger.error(f"‚ùå Error scrapers gen√©ricos Argentina: {e}")
            return []

# üá™üá∏ ESPA√ëA COUNTRY FACTORY
class SpainFactory(BaseFactory):
    """
    üá™üá∏ Factory Espa√±a - maneja todo el pa√≠s
    """
    
    def __init__(self, location: str, region: Optional[str] = None):
        super().__init__(location)
        self.region = region
        
    @property
    def name(self) -> str:
        if self.region:
            return f"Spain_{self.region}_Factory"
        return "Spain_National_Factory"
        
    async def _execute_internal(self) -> List[Dict[str, Any]]:
        """L√≥gica de Espa√±a"""
        try:
            from api.multi_source import fetch_all_progressive
            
            # Usar multi_source para Espa√±a
            result = await fetch_all_progressive(location=self.location, fast=True)
            
            if result and "events" in result:
                return result["events"]
            return []
            
        except Exception as e:
            logger.error(f"‚ùå Error en scrapers Espa√±a: {e}")
            return []

# üá∫üá∏ USA COUNTRY FACTORY  
class USAFactory(BaseFactory):
    """
    üá∫üá∏ Factory USA - maneja todo el pa√≠s
    """
    
    def __init__(self, location: str, state: Optional[str] = None):
        super().__init__(location)
        self.state = state
        
    @property
    def name(self) -> str:
        if self.state:
            return f"USA_{self.state}_Factory"
        return "USA_National_Factory"
        
    async def _execute_internal(self) -> List[Dict[str, Any]]:
        """L√≥gica de USA"""
        try:
            from api.multi_source import fetch_all_progressive
            
            # Usar multi_source para USA
            result = await fetch_all_progressive(location=self.location, fast=True)
            
            if result and "events" in result:
                return result["events"]
            return []
            
        except Exception as e:
            logger.error(f"‚ùå Error en scrapers USA: {e}")
            return []

# üåç MASTER FACTORY - Entry Point
class MasterFactory:
    """
    üåç Master Factory - Entry point que decide qu√© country factory usar
    """
    
    @staticmethod
    def create_scraper(location: str) -> IScraper:
        """
        Factory method principal - detecta pa√≠s vs provincia
        üéØ REGLA CLAVE: Si es provincia espec√≠fica ‚Üí IR DIRECTO al Provincial Factory
        """
        location_lower = location.lower().strip()
        
        # üèõÔ∏è PROVINCIAS ARGENTINAS - VAN DIRECTO AL PROVINCIAL (NO PASAN POR PA√çS)
        if any(keyword in location_lower for keyword in ["c√≥rdoba", "cordoba"]):
            logger.info("üèõÔ∏è Provincia espec√≠fica detectada: C√≥rdoba - DIRECTO a Provincial Factory")
            return ArgentinaProvincialFactory(location, province="C√≥rdoba")
            
        elif any(keyword in location_lower for keyword in ["mendoza"]):
            logger.info("üèõÔ∏è Provincia espec√≠fica detectada: Mendoza - DIRECTO a Provincial Factory")  
            return ArgentinaProvincialFactory(location, province="Mendoza")
            
        elif any(keyword in location_lower for keyword in ["buenos aires", "buenosaires", "caba"]):
            logger.info("üèõÔ∏è Provincia espec√≠fica detectada: Buenos Aires - DIRECTO a Provincial Factory")
            return ArgentinaProvincialFactory(location, province="Buenos Aires")
            
        # üá¶üá∑ ARGENTINA PA√çS COMPLETO - USA COUNTRY FACTORY
        elif any(keyword in location_lower for keyword in ["argentina", "arg"]):
            logger.info("üá¶üá∑ Pa√≠s completo detectado: Argentina - usando Country Factory")
            return ArgentinaFactory(location)
            
        # üá™üá∏ ESPA√ëA
        elif any(keyword in location_lower for keyword in ["barcelona", "madrid", "valencia", "espa√±a", "spain"]):
            return SpainFactory(location)
            
        # üá∫üá∏ USA
        elif any(keyword in location_lower for keyword in ["miami", "new york", "los angeles", "usa", "united states"]):
            return USAFactory(location)
            
        # Fallback a Argentina provincial (m√°s espec√≠fico)
        else:
            logger.warning(f"‚ö†Ô∏è Ubicaci√≥n no reconocida '{location}', usando Argentina Provincial como fallback")
            return ArgentinaProvincialFactory(location, province="Generic")

# üéØ FUNCI√ìN PRINCIPAL - Entry Point
async def get_events_hierarchical(location: str) -> Dict[str, Any]:
    """
    üéØ Entry point principal - usa architecture jer√°rquica
    """
    try:
        # Crear factory apropiado
        scraper = MasterFactory.create_scraper(location)
        
        # Ejecutar
        events = await scraper.execute()
        
        # Formato de respuesta
        return {
            "status": "success",
            "location": location,
            "scraper_used": scraper.name,
            "events": events,
            "count": len(events),
            "message": f"‚úÖ {scraper.name}: {len(events)} eventos"
        }
        
    except Exception as e:
        logger.error(f"‚ùå Error en factory jer√°rquico: {e}")
        return {
            "status": "error",
            "location": location,
            "events": [],
            "count": 0,
            "error": str(e),
            "message": f"‚ùå Error: {str(e)}"
        }