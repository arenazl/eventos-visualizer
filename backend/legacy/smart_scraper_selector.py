"""
Smart Scraper Selector - Sistema h√≠brido inteligente
Combina detecci√≥n r√°pida + IA contextual para elegir scrapers √≥ptimos
"""

from typing import List, Dict, Any, Optional, Tuple
import re
import logging
from datetime import datetime
from enum import Enum

logger = logging.getLogger(__name__)

class Intent(Enum):
    GENERAL = "general"
    NIGHTLIFE = "nightlife"
    MUSIC = "music"
    SPORTS = "sports"
    CULTURAL = "cultural"
    FOOD = "food"
    BUSINESS = "business"
    ROMANTIC = "romantic"
    FAMILY = "family"

class ScraperSelector:
    """
    Sistema h√≠brido para seleccionar scrapers inteligentemente
    """
    
    def __init__(self):
        # üó∫Ô∏è SCRAPERS POR CIUDAD (O(1) lookup)
        self.SCRAPERS_BY_CITY = {
            # Espa√±a
            "Barcelona": {
                "primary": ["barcelona_scraper"],
                "secondary": ["ticketmaster_global", "timeout_barcelona"],
                "specialties": {
                    Intent.NIGHTLIFE: ["barcelona_nightlife"],
                    Intent.MUSIC: ["primavera_sound", "razzmatazz"],
                    Intent.SPORTS: ["camp_nou_scraper"],
                    Intent.CULTURAL: ["palau_musica", "cccb_scraper"]
                }
            },
            "Madrid": {
                "primary": ["madrid_scraper"],
                "secondary": ["ticketmaster_global", "timeout_madrid"],
                "specialties": {
                    Intent.SPORTS: ["bernabeu_scraper", "wanda_scraper"],
                    Intent.MUSIC: ["wizink_center"],
                    Intent.CULTURAL: ["reina_sofia", "prado_scraper"]
                }
            },
            
            # Francia  
            "Paris": {
                "primary": ["paris_scraper"],
                "secondary": ["ticketmaster_global", "sortir_paris"],
                "specialties": {
                    Intent.CULTURAL: ["louvre_scraper", "orsay_scraper"],
                    Intent.MUSIC: ["olympia_scraper", "zenith_paris"],
                    Intent.SPORTS: ["parc_princes"]
                }
            },
            
            # Argentina
            "Buenos Aires": {
                "primary": ["argentina_venues_scraper", "oficial_venues_scraper"],
                "secondary": ["eventbrite_massive", "timeout_baires"],
                "specialties": {
                    Intent.SPORTS: ["luna_park", "estadio_obras"],
                    Intent.CULTURAL: ["teatro_colon", "ccr_scraper"],
                    Intent.MUSIC: ["niceto_club", "groove_scraper"]
                }
            },
            "Mendoza": {
                "primary": ["mendoza_scraper"],
                "secondary": ["provincial_scrapers"],
                "specialties": {
                    Intent.FOOD: ["bodegas_scraper", "wine_tours"]
                }
            },
            "C√≥rdoba": {
                "primary": ["cordoba_scraper"],
                "secondary": ["provincial_scrapers"],
                "specialties": {
                    Intent.MUSIC: ["quality_espacio", "plaza_musica"]
                }
            },
            
            # M√©xico
            "Mexico City": {
                "primary": ["cdmx_scraper"],
                "secondary": ["ticketmaster_mexico", "timeout_cdmx"],
                "specialties": {
                    Intent.CULTURAL: ["palacio_bellas_artes", "antropologia"],
                    Intent.SPORTS: ["azteca_scraper", "foro_sol"]
                }
            }
        }
        
        # üéØ INTENT DETECTION KEYWORDS
        self.INTENT_KEYWORDS = {
            Intent.NIGHTLIFE: ["bar", "club", "fiesta", "party", "discoteca", "night", "drinks", "copas"],
            Intent.MUSIC: ["concierto", "m√∫sica", "concert", "band", "dj", "festival", "show"],
            Intent.SPORTS: ["f√∫tbol", "football", "partido", "match", "deporte", "sport", "estadio"],
            Intent.CULTURAL: ["museo", "arte", "exposici√≥n", "culture", "gallery", "theater", "teatro"],
            Intent.FOOD: ["restaurante", "comida", "food", "wine", "vino", "gastronomy", "chef"],
            Intent.BUSINESS: ["networking", "conference", "business", "trabajo", "professional"],
            Intent.ROMANTIC: ["rom√°ntico", "romantic", "pareja", "date", "√≠ntimo", "couple"],
            Intent.FAMILY: ["familia", "family", "kids", "ni√±os", "children", "infantil"]
        }
        
        # üåç CITY ALIASES (m√°s completo que antes)
        self.CITY_ALIASES = {
            # Espa√±a
            "barcelona": "Barcelona", "bcn": "Barcelona", "barna": "Barcelona",
            "madrid": "Madrid", "capital espa√±a": "Madrid",
            "valencia": "Valencia", "sevilla": "Sevilla",
            
            # Francia
            "paris": "Paris", "par√≠s": "Paris", "ville lumi√®re": "Paris",
            "lyon": "Lyon", "marseille": "Marseille",
            
            # Argentina
            "buenos aires": "Buenos Aires", "baires": "Buenos Aires", "caba": "Buenos Aires",
            "capital": "Buenos Aires", "ciudad aut√≥noma": "Buenos Aires",
            "mendoza": "Mendoza", "mza": "Mendoza",
            "c√≥rdoba": "C√≥rdoba", "cordoba": "C√≥rdoba", "la docta": "C√≥rdoba",
            
            # M√©xico
            "cdmx": "Mexico City", "ciudad de m√©xico": "Mexico City", "df": "Mexico City",
            "guadalajara": "Guadalajara", "gdl": "Guadalajara"
        }

    def analyze_query(self, query: str) -> Tuple[Optional[str], Intent, Dict[str, Any]]:
        """
        Analiza query y retorna: (ciudad, intent, contexto)
        """
        query_lower = query.lower().strip()
        
        # 1. üèôÔ∏è DETECCI√ìN DE CIUDAD (r√°pido)
        detected_city = self._detect_city(query_lower)
        
        # 2. üéØ DETECCI√ìN DE INTENT (keywords)  
        detected_intent = self._detect_intent(query_lower)
        
        # 3. üìä CONTEXTO ADICIONAL
        context = self._extract_context(query_lower)
        
        logger.info(f"üß† Query analysis: city='{detected_city}', intent='{detected_intent.value}', context={context}")
        
        return detected_city, detected_intent, context

    def select_scrapers(self, city: str, intent: Intent, context: Dict[str, Any] = None) -> List[str]:
        """
        Selecciona scrapers √≥ptimos basado en ciudad + intent + contexto
        """
        if city not in self.SCRAPERS_BY_CITY:
            logger.warning(f"‚ö†Ô∏è Ciudad '{city}' no soportada, usando scrapers por defecto")
            return ["multi_source_scraper"]
        
        city_config = self.SCRAPERS_BY_CITY[city]
        selected_scrapers = []
        
        # 1. Scrapers primarios (siempre)
        selected_scrapers.extend(city_config["primary"])
        
        # 2. Scrapers especializados seg√∫n intent
        if intent in city_config.get("specialties", {}):
            specialty_scrapers = city_config["specialties"][intent]
            selected_scrapers.extend(specialty_scrapers)
            logger.info(f"‚ú® Agregando scrapers especializados para {intent.value}: {specialty_scrapers}")
        
        # 3. Scrapers secundarios (si necesitamos m√°s cobertura)
        context = context or {}
        if context.get("need_comprehensive", False) or len(selected_scrapers) < 2:
            selected_scrapers.extend(city_config.get("secondary", []))
        
        # 4. Eliminar duplicados y validar
        unique_scrapers = list(dict.fromkeys(selected_scrapers))  # Preserva orden
        
        logger.info(f"üéØ Selected scrapers for {city} ({intent.value}): {unique_scrapers}")
        
        return unique_scrapers

    def _detect_city(self, query_lower: str) -> Optional[str]:
        """
        Detecci√≥n r√°pida de ciudad usando aliases
        """
        for alias, city in self.CITY_ALIASES.items():
            if alias in query_lower:
                logger.info(f"üèôÔ∏è Ciudad detectada: '{alias}' ‚Üí {city}")
                return city
        return None

    def _detect_intent(self, query_lower: str) -> Intent:
        """
        Detecci√≥n de intent usando keywords
        """
        intent_scores = {}
        
        for intent, keywords in self.INTENT_KEYWORDS.items():
            score = sum(1 for keyword in keywords if keyword in query_lower)
            if score > 0:
                intent_scores[intent] = score
        
        if intent_scores:
            best_intent = max(intent_scores.items(), key=lambda x: x[1])[0]
            logger.info(f"üéØ Intent detectado: {best_intent.value} (score: {intent_scores[best_intent]})")
            return best_intent
        
        return Intent.GENERAL

    def _extract_context(self, query_lower: str) -> Dict[str, Any]:
        """
        Extrae contexto adicional del query
        """
        context = {}
        
        # Tiempo
        if any(word in query_lower for word in ["hoy", "today", "tonight", "esta noche"]):
            context["timeframe"] = "today"
        elif any(word in query_lower for word in ["ma√±ana", "tomorrow"]):
            context["timeframe"] = "tomorrow"  
        elif any(word in query_lower for word in ["fin de semana", "weekend", "s√°bado", "domingo"]):
            context["timeframe"] = "weekend"
        
        # Presupuesto
        if any(word in query_lower for word in ["barato", "cheap", "gratis", "free", "sin plata"]):
            context["budget"] = "low"
        elif any(word in query_lower for word in ["premium", "caro", "luxury", "expensive"]):
            context["budget"] = "high"
        
        # Social context
        if any(word in query_lower for word in ["solo", "alone", "individual"]):
            context["social"] = "solo"
        elif any(word in query_lower for word in ["amigos", "friends", "grupo"]):
            context["social"] = "group"
        elif any(word in query_lower for word in ["pareja", "couple", "novia", "novio"]):
            context["social"] = "couple"
        
        # Comprehensiveness
        if any(word in query_lower for word in ["todo", "all", "completo", "comprehensive"]):
            context["need_comprehensive"] = True
        
        return context

    def get_available_cities(self) -> List[str]:
        """
        Retorna lista de ciudades soportadas
        """
        return list(self.SCRAPERS_BY_CITY.keys())

    def get_city_specialties(self, city: str) -> Dict[str, List[str]]:
        """
        Retorna especialidades disponibles para una ciudad
        """
        if city not in self.SCRAPERS_BY_CITY:
            return {}
        
        specialties = {}
        city_specialties = self.SCRAPERS_BY_CITY[city].get("specialties", {})
        
        for intent, scrapers in city_specialties.items():
            specialties[intent.value] = scrapers
        
        return specialties


# üß™ Testing functions
def test_scraper_selector():
    """
    Prueba el selector de scrapers
    """
    selector = ScraperSelector()
    
    test_queries = [
        "eventos en barcelona",
        "conciertos en madrid este fin de semana", 
        "bares copados en barna para ir con amigos",
        "museos en paris para una cita rom√°ntica",
        "partidos de f√∫tbol en buenos aires",
        "algo barato en mendoza para hacer solo",
        "eventos premium en cdmx"
    ]
    
    print("üß† Testing Smart Scraper Selector...")
    print("=" * 50)
    
    for query in test_queries:
        print(f"\nüìù Query: '{query}'")
        
        city, intent, context = selector.analyze_query(query)
        scrapers = selector.select_scrapers(city or "Buenos Aires", intent, context)
        
        print(f"   üèôÔ∏è City: {city or 'None (default: Buenos Aires)'}")
        print(f"   üéØ Intent: {intent.value}")
        print(f"   üìä Context: {context}")
        print(f"   üîß Scrapers: {scrapers}")

if __name__ == "__main__":
    test_scraper_selector()