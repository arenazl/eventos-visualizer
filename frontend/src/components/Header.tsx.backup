import React, { useState, useEffect, useRef } from 'react'
import { MagnifyingGlassIcon, MapPinIcon } from '@heroicons/react/24/outline'
import { useNavigate } from 'react-router-dom'
import { API_BASE_URL } from '../config/api'

interface LocationSuggestion {
  name: string
  displayName: string
  country: string  // Nombre completo del paÃ­s
  countryCode: string  // CÃ³digo ISO para la bandera
  lat: number
  lon: number
}

interface HeaderProps {
  searchQuery?: string
  onSearchChange?: (value: string) => void
  onSearchSubmit?: () => void
  onVoiceSearch?: () => void
  onLocationClick?: () => void
  isSearching?: boolean
  onLocationSelect?: (location: LocationSuggestion) => void
  showBackButton?: boolean
  onBackClick?: () => void
  currentLocation?: string
}

const Header: React.FC<HeaderProps> = ({
  searchQuery = '',
  onSearchChange = () => {},
  onSearchSubmit = () => {},
  onVoiceSearch = () => {},
  onLocationClick = () => {},
  isSearching = false,
  onLocationSelect = () => {},
  showBackButton = false,
  onBackClick = () => {},
  currentLocation
}) => {
  const navigate = useNavigate()
  const [isScrolled, setIsScrolled] = useState(false)
  const [suggestions, setSuggestions] = useState<LocationSuggestion[]>([])
  const [showSuggestions, setShowSuggestions] = useState(false)
  const [isLoadingSuggestions, setIsLoadingSuggestions] = useState(false)
  const suggestionsRef = useRef<HTMLDivElement>(null)
  const justSelectedRef = useRef(false) // ðŸ”’ Evita reabrir dropdown despuÃ©s de seleccionar
  const abortControllerRef = useRef<AbortController | null>(null) // ðŸ›‘ Cancela requests anteriores
  const cacheRef = useRef<Map<string, LocationSuggestion[]>>(new Map()) // ðŸ’¾ Cache de sugerencias
  const [nearbyCitiesLoaded, setNearbyCitiesLoaded] = useState(false) // ðŸŒ Ciudades cercanas ya cargadas
  const [isHoveringInput, setIsHoveringInput] = useState(false) // ðŸ–±ï¸ Mouse sobre input

  useEffect(() => {
    let lastScrollY = window.scrollY

    const handleScroll = () => {
      const currentScrollY = window.scrollY

      // Hysteresis: diferentes thresholds para evitar oscilaciÃ³n
      if (currentScrollY > lastScrollY) {
        // Scrolling DOWN: activar despuÃ©s de 100px
        if (currentScrollY > 100) {
          setIsScrolled(true)
        }
      } else {
        // Scrolling UP: desactivar antes de 20px
        if (currentScrollY < 20) {
          setIsScrolled(false)
        }
      }

      lastScrollY = currentScrollY
    }

    window.addEventListener('scroll', handleScroll)
    return () => window.removeEventListener('scroll', handleScroll)
  }, [])

  // ðŸ” Buscar sugerencias de ubicaciÃ³n con debounce y cache
  useEffect(() => {
    const fetchSuggestions = async () => {
      // ðŸ”’ NO abrir si acabamos de seleccionar del dropdown
      if (justSelectedRef.current) {
        return
      }

      if (!searchQuery || searchQuery.length < 3) {
        setSuggestions([])
        setShowSuggestions(false)
        return
      }

      // ðŸ’¾ Verificar cache primero
      const cachedResults = cacheRef.current.get(searchQuery.toLowerCase())
      if (cachedResults) {
        console.log('âœ… Cache hit para:', searchQuery)
        setSuggestions(cachedResults)
        setShowSuggestions(cachedResults.length > 0)
        return
      }

      // ðŸ›‘ Cancelar request anterior si existe
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }

      // ðŸ†• Crear nuevo AbortController
      const abortController = new AbortController()
      abortControllerRef.current = abortController

      setIsLoadingSuggestions(true)

      try {
        // ðŸ—„ï¸ Usar backend para obtener solo ciudades con eventos
        const response = await fetch(
          `${API_BASE_URL}/api/cities/available?q=${encodeURIComponent(searchQuery)}&limit=10`,
          { signal: abortController.signal }
        )

        // âš ï¸ Si el request fue cancelado, no continuar
        if (abortController.signal.aborted) {
          return
        }

        const data = await response.json()

        // ðŸ“‹ Mapear respuesta del backend al formato LocationSuggestion
        const locationSuggestions: LocationSuggestion[] = (data.locations || []).map((item: any) => {
          return {
            name: item.location,
            displayName: item.displayName || `${item.location} (${item.event_count} eventos)`,
            country: item.location_type || '', // Tipo: city, province, country
            countryCode: '',
            lat: 0, // Coordenadas no necesarias para bÃºsqueda en DB
            lon: 0
          }
        })

        // ðŸ’¾ Guardar en cache
        cacheRef.current.set(searchQuery.toLowerCase(), locationSuggestions)
        console.log('ðŸ’¾ Guardado en cache:', searchQuery, locationSuggestions.length, 'ubicaciones con eventos (ciudades/provincias/paÃ­ses)')

        setSuggestions(locationSuggestions)
        setShowSuggestions(locationSuggestions.length > 0)
      } catch (error) {
        // âš ï¸ Si es AbortError, no mostrar error (es normal)
        if (error instanceof Error && error.name === 'AbortError') {
          console.log('â¹ï¸ Request cancelado:', searchQuery)
          return
        }
        console.error('Error fetching suggestions:', error)
        setSuggestions([])
      } finally {
        setIsLoadingSuggestions(false)
      }
    }

    // ðŸ• Debounce aumentado a 600ms para reducir requests
    const debounceTimer = setTimeout(fetchSuggestions, 600)
    return () => {
      clearTimeout(debounceTimer)
      // ðŸ›‘ Cleanup: Cancelar request si el componente se desmonta o searchQuery cambia
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
    }
  }, [searchQuery])

  // Cerrar sugerencias al hacer clic fuera
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (suggestionsRef.current && !suggestionsRef.current.contains(event.target as Node)) {
        setShowSuggestions(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      setShowSuggestions(false)
      onSearchSubmit()
    } else if (e.key === 'Escape') {
      setShowSuggestions(false)
    }
  }

  const handleSuggestionClick = (suggestion: LocationSuggestion) => {
    // ðŸ”’ Marcar que acabamos de seleccionar (evita reabrir dropdown)
    justSelectedRef.current = true

    // Llenar el input con el texto (solo el nombre de la ciudad)
    onSearchChange(suggestion.name)
    setShowSuggestions(false)

    // ðŸ”¥ Actualizar la ubicaciÃ³n en el store y ejecutar bÃºsqueda
    onLocationSelect({
      name: suggestion.name,
      country: suggestion.country || '',
      lat: suggestion.lat,
      lon: suggestion.lon
    })

    // ðŸ”’ Resetear flag despuÃ©s de 1 segundo (permite escribir de nuevo)
    setTimeout(() => {
      justSelectedRef.current = false
    }, 1000)
  }

  // ðŸŒ Cargar ciudades cercanas basadas en IP al hacer hover
  const handleInputHover = async () => {
    // Si ya se cargaron o el usuario ya estÃ¡ escribiendo, no hacer nada
    if (nearbyCitiesLoaded || searchQuery.length > 0) {
      return
    }

    setIsLoadingSuggestions(true)
    setShowSuggestions(true)
    setIsHoveringInput(true)

    try {
      // Detectar ubicaciÃ³n por IP
      const ipResponse = await fetch(`${API_BASE_URL}/api/location/detect`)
      const ipData = await ipResponse.json()

      if (ipData.success && ipData.location) {
        const { name: cityName } = ipData.location

        // Pedir a IA ciudades cercanas a esta ubicaciÃ³n
        const nearbyResponse = await fetch(
          `${API_BASE_URL}/api/ai/nearby-cities?location=${encodeURIComponent(cityName)}&limit=10`
        )
        const nearbyData = await nearbyResponse.json()

        if (nearbyData.success && nearbyData.cities) {
          // Mapear ciudades cercanas a LocationSuggestion
          const nearbyCities: LocationSuggestion[] = nearbyData.cities.map((city: any) => ({
            name: city.name,
            displayName: city.displayName || `${city.name} (${city.distance || 'Cercana'})`,
            country: city.country || '',
            countryCode: city.countryCode || '',
            lat: city.lat || 0,
            lon: city.lon || 0
          }))

          setSuggestions(nearbyCities)
          setNearbyCitiesLoaded(true)
        }
      }
    } catch (error) {
      console.error('Error loading nearby cities:', error)
      setSuggestions([])
    } finally {
      setIsLoadingSuggestions(false)
    }
  }

  return (
    <header className={`backdrop-blur-3xl bg-white/5 sticky top-0 z-50 transition-all duration-300 border-b border-white/10 ${
      isScrolled ? 'py-2' : 'py-2 md:py-3'
    }`}>
      <div className="max-w-7xl mx-auto px-3 md:px-6">
        <div className="flex items-center justify-between gap-2 md:gap-6">
          {/* Logo a la izquierda con flecha opcional */}
          <div className="flex items-center gap-2 md:gap-3 flex-shrink-0">
            {showBackButton && (
              <button
                onClick={onBackClick}
                className="p-1.5 md:p-2 hover:bg-white/10 rounded-full transition-colors text-white/80 hover:text-white"
                title="Volver"
              >
                <svg className="w-5 h-5 md:w-6 md:h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                </svg>
              </button>
            )}
            <h1
              onClick={() => navigate('/')}
              className={`font-black text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-purple-500 to-indigo-500 tracking-wider transition-all duration-300 cursor-pointer hover:scale-105 ${
              isScrolled ? 'text-base md:text-xl' : 'text-lg md:text-2xl'
            }`}>
              <span className="hidden sm:inline">FunAroundYou âœ¨</span>
              <span className="sm:hidden">Fun âœ¨</span>
            </h1>
          </div>

          {/* Buscador en el medio */}
          <div className="flex-1 max-w-2xl">
            <div className="relative group" ref={suggestionsRef}>
              <div className="relative bg-black/40 backdrop-blur-xl border border-white/30 rounded-full shadow-lg hover:shadow-xl transition-all duration-300">
                <div className="flex items-center gap-1 md:gap-2 px-2 md:px-4">
                  <MagnifyingGlassIcon className="w-4 h-4 md:w-5 md:h-5 text-white/60 flex-shrink-0" />
                  <input
                    type="text"
                    value={searchQuery}
                    onChange={(e) => {
                      console.log('ðŸ”¥ Header onChange:', e.target.value)
                      onSearchChange(e.target.value)
                      // Resetear ciudades cercanas para permitir bÃºsqueda en DB
                      if (e.target.value.length > 0) {
                        setNearbyCitiesLoaded(false)
                      }
                    }}
                    onKeyDown={handleKeyDown}
                    onMouseEnter={handleInputHover}
                    onFocus={() => {
                      // Si no hay query, intentar cargar ciudades cercanas
                      if (searchQuery.length === 0) {
                        handleInputHover()
                      } else if (searchQuery.length >= 3 && suggestions.length > 0) {
                        setShowSuggestions(true)
                      }
                    }}
                    placeholder="Ciudad, provincia o paÃ­s..."
                    className={`w-full bg-transparent text-white placeholder-white/40 outline-none font-medium transition-all duration-300 ${
                      isScrolled ? 'py-2 text-xs md:text-sm' : 'py-2 md:py-3 text-xs md:text-base'
                    }`}
                  />
                  <button
                    onClick={onVoiceSearch}
                    className="hidden md:block p-2 rounded-full transition-all duration-300 bg-white/10 hover:bg-white/20 flex-shrink-0"
                    title="BÃºsqueda por voz"
                  >
                    <svg className="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 24 24">
                      <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                      <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                    </svg>
                  </button>
                  <button
                    onClick={onSearchSubmit}
                    disabled={isSearching}
                    className={`p-1.5 md:p-2 rounded-full transition-all duration-300 flex-shrink-0 ${
                      isSearching
                        ? 'bg-gradient-to-r from-indigo-600 to-purple-700'
                        : 'bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500'
                    } disabled:opacity-50`}
                    title="Buscar"
                  >
                    {isSearching ? (
                      <div className="w-4 h-4 md:w-5 md:h-5 border-2 border-white/30 border-t-white rounded-full animate-spin"></div>
                    ) : (
                      <MagnifyingGlassIcon className="w-4 h-4 md:w-5 md:h-5 text-white" />
                    )}
                  </button>
                </div>
              </div>

              {/* Dropdown de sugerencias */}
              {showSuggestions && suggestions.length > 0 && (
                <div className="absolute top-full left-0 right-0 mt-2 bg-gray-900/95 backdrop-blur-xl border border-white/20 rounded-2xl shadow-2xl overflow-hidden z-50">
                  {isLoadingSuggestions && (
                    <div className="p-4 text-center text-white/60">
                      <div className="inline-block w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin"></div>
                    </div>
                  )}
                  {!isLoadingSuggestions && suggestions.map((suggestion, index) => (
                    <button
                      key={index}
                      onClick={() => handleSuggestionClick(suggestion)}
                      className="w-full px-4 py-3 text-left hover:bg-white/10 transition-colors border-b border-white/5 last:border-b-0 group"
                    >
                      <div className="flex items-center gap-3">
                        <MapPinIcon className="w-5 h-5 text-purple-400 flex-shrink-0" />
                        <div className="flex-1 min-w-0">
                          <div className="text-white font-medium truncate">{suggestion.name}</div>
                          <div className="text-white/50 text-sm truncate">{suggestion.displayName}</div>
                        </div>
                      </div>
                    </button>
                  ))}
                </div>
              )}
            </div>
          </div>

          {/* Botones a la derecha */}
          <div className="flex items-center gap-1.5 md:gap-3 flex-shrink-0">
            <button
              onClick={onLocationClick}
              className="p-1.5 md:p-2 text-white/70 hover:text-white transition-colors rounded-full hover:bg-white/10"
              title="Cambiar ubicaciÃ³n"
            >
              <MapPinIcon className="h-5 w-5 md:h-6 md:w-6" />
            </button>
            <button className="hidden sm:block bg-white/10 hover:bg-white/20 text-white font-semibold py-1.5 md:py-2 px-3 md:px-6 border border-white/30 rounded-full shadow-md hover:shadow-lg transition-all duration-200">
              <span className={isScrolled ? 'text-xs md:text-sm' : 'text-sm md:text-base'}>Registrarse</span>
            </button>
          </div>
        </div>
      </div>
    </header>
  )
}

export default Header